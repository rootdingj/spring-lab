Java 关键字
====================
# 一、static 修饰符

static修饰符可以用来修饰类的成员变量、成员方法和代码块：
-  用static修饰的成员变量表示静态变量，可以直接通过类名来访问；
- 用static修饰的成员方法表示静态方法，可以直接通过类名来访问；
- 用static修饰的程序代码表示静态代码块，当Java虚似机加载类时，就会执行该代码块；

## 1.static 变量
成员变量：定义在类里面、方法外面的变量, 分两种：
- a. 实例变量;
- b. 静态变量；形式和实例变量类似，在实例变量前面加static关键字；

static变量和实例变量的区别：
- a.static变量对于每个类而言在内存中只有一个，能被类的所有实例所共享；实例变量对于每   个类的每个实例都有一份，它们之间互不影响；
- b.Java虚拟机在加载类的过程中为static变量分配内存，实例变量在加载完类后创建对象时分   配内存；
- c.static变量可以直接通过类名访问，实例变量通过引用类型访问变量；
                              
## 2.static 方法
成员方法分为静态方法和实例方法，用static修饰的方法叫静态方法，或类方法。静态方法也和静态变量一样，不需要创建类的实例，可以直接通过类名来访问。静态方法：随时准备给调用。

- a.static方法不可以直接访问所属类的实例变量和实例方法，直接访问所属类的静态变量和静态方法；
- b.父类的静态方法不能被子类覆为非静态方法；
- c.父类的非静态方法不能被子类覆盖为静态方法。
 
 注：1) 不能使用this关键字；
   2)不能使用super关键字,super关键字用来访问当前实例从父类中继承的方法和属性。supe  r关键字与类的特定实例相关；
   3)静态方法必须被实现。静态方法用来表示某个类所特有的功能，这种功能的实现不依赖   于类的具体实例，也不依赖于它的子类。
			
被static所修饰的成员变量和成员方法表明归某个类所有，它不依赖于类的特定实例，被类的所有实例共享。
	
## 3. static代码块                  

类中可以包含静态代码块，它不存于任何方法中。在Java虚拟机中加载类时会执行这些静态代码块。如果类中包含多个静态代码块，那么Java虚拟机将按照它们在类中出现的顺序依次执行它们，每个静态代码块只会被执行一次。

## 4. 静态导入

使用静态成员（方法和变量）我们必须给出提供这个静态成员的类。使用静态导入可以使被导入类的静态变量和静态方法在当前类中可以直接使用，使用这些静态成员无需再在前面写上他们所属的类名。
```java
import static java.lang.Math.random;
import static java.lang.Math.PI;
public class Test {	
	public static void main(String[] args) {
		//之前是需要Math.random()调用的
		System.out.println(random());
		System.out.println(PI);				
	}			
}
```
		
# 二. final修改符

final具有"不可改变的"含义，它可以修饰非抽象类、非抽象成员方法和变量。
- 用final修饰的类不能被继承，没有子类；
- 用final修饰的方法不能被子类的方法覆盖；
- 用final修饰的变量表示常量，只能被赋一次值；

final不能用来修饰构造方法，因为"方法覆盖"这一概念仅适用于类的成员方法，而不适用于类的构造方法，父类的构造方法和子类的构造方法之间不存在覆盖关系. 因此用final修饰构造方法是无意义的。父类中用private修饰的方法不能被子类的方法覆盖，因此private类型的方法默认是final类型的。

## 1.final类

继承关系的弱点是打破封装，子类能够访问父类的方法，而且能以方法覆盖的方式修改实现细节。在以下情况下,可以考虑把类定义为final类型，使得这个类不能被继承。
- 子类有可能会错误地修改父类的实现细节；
- 出于安全，类的实现细节不允许有任何改动；
- 在创建对象模型时，确信这个类不会再被扩展；

## 2.final方法；
 
某些情况下，出于安全原因，父类不允许子类覆盖某个方法， 此时可以把这个方法声明为final类型。例如在java.lang.Object类中，getClass()方法为final类型。

## 3. final变量：
   
final修饰的属性(成员变量)赋值的位置:
- 非静态的成员变量
	1.声明的同时
	2.匿名代码块
	3.构造器(类中出现的所有构造器)

- 静态的成员变量
	1.声明的同时
	2.static代码块		    
		  a.final可以修饰静态变量、实例变量、局部变量；
		  b.final变量都必须显示初始化，否则会导致编译错误；因为他是final所以JVM不会给他默认值，根据先定义、再初始化、后使用的原则。。
			 1) 静态变量，定义变量时进行初始化或者static代码块中赋值；
			 2) 实例变量，可以在定义变量时，或者在构造方法中进行初始化；
		  c.final变量只能赋一次值。
				            
# 三、abstract修饰符

可用来修饰类和成员方法。
- 用abstract修饰的类表示抽象类，抽象类不能实例化，即不允许创建抽象类本身的实例。没有用abstract修饰的类称为具体类，具体类可以被实例化。
- 用abstract修饰的方法表示抽象方法，抽象方法没有方法体。抽象方法用来描述系统具有什么功能 ，但不提供具体的实现。没有abstract修饰的方法称为具体方法，具体方法具有方法体。
            
语法规则：
- 抽象类中可以没有抽象方法，但包含了抽象方法的类必须被定义为抽象类；
- 没有抽象构造方法，也没有抽象静态方法；
- 抽象类中可以有非抽象的构造方法；
- 抽象类及抽象方法不能被final修饰符修饰；
- 继承这个抽象类在创建对象，就可以调用方法了，继承过来要实现他的方法{}；
- 有抽象方法的类一定是抽象类，抽象类不一定有抽象方法。

